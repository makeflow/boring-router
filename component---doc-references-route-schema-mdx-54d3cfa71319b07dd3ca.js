(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{qxq1:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return c})),n.d(t,"default",(function(){return u}));n("5hJT"),n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("PJhk"),n("mXGw");var a=n("/FXl"),r=n("TjRS");n("aD51");function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"doc/references/route-schema.mdx"}});var i={_frontmatter:c},s=r.a;function u(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(s,o({},i,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"route-schema"},"Route Schema"),Object(a.b)("h2",{id:"overview"},"Overview"),Object(a.b)("p",null,"Boring Router defines routes by tree-structure route schemas:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  account: {\n    $children: {\n      accountId: {\n        $match: /\\d+/,\n        $children: {\n          profile: {\n            $query: {\n              'show-comment': true,\n            },\n          },\n          contact: true,\n        },\n      },\n    },\n  },\n});\n")),Object(a.b)("p",null,"The route defined above matches paths like below:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"/account/123/profile\n/account/123/profile?show-comment=on\n/account/456/contact\n")),Object(a.b)("p",null,"And it creates route objects (",Object(a.b)("inlineCode",{parentName:"p"},"RouteMatch"),") that can be accessed using:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"route;\nroute.account;\nroute.account.accountId;\nroute.account.accountId.profile;\nroute.account.accountId.contact;\n")),Object(a.b)("p",null,"To get a parameter (including segment parameter and query string) from a route, we need to access ",Object(a.b)("inlineCode",{parentName:"p"},"$params")," of the target route object."),Object(a.b)("p",null,"In this case, to get ",Object(a.b)("inlineCode",{parentName:"p"},"accountId"),", we need to use ",Object(a.b)("inlineCode",{parentName:"p"},"route.account.accountId.$params.accountId"),". This might look a little bit weird at the beginning (may be forever), but it's also reasonable: because ",Object(a.b)("inlineCode",{parentName:"p"},"accountId")," (the segment parameter) is one of the properties of route ",Object(a.b)("inlineCode",{parentName:"p"},"route.account.accountId"),", and its name by convention is the same as the route key."),Object(a.b)("p",null,"We can also get the parameter from a child route object, e.g.: ",Object(a.b)("inlineCode",{parentName:"p"},"route.account.accountId.profile.$params.accountId"),"."),Object(a.b)("h2",{id:"match"},"Match"),Object(a.b)("p",null,"By adding a child under schema root or ",Object(a.b)("inlineCode",{parentName:"p"},"$children"),", we create a ",Object(a.b)("inlineCode",{parentName:"p"},"RouteMatch")," for the correspondent segment:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  // Simply use `true` for default options.\n  workbench: true,\n  // Specify route options with an object.\n  settings: {\n    $match: /boring/,\n    $children: {\n      security: true,\n      notification: true,\n    },\n  },\n});\n")),Object(a.b)("h3",{id:"segment-match"},"Segment Match"),Object(a.b)("p",null,'By default, Boring Router matches a segment according to the "hyphenated" string of the route key.'),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  // This matches `/user-settings`.\n  userSettings: true,\n});\n")),Object(a.b)("p",null,"To match another fixed string, we may add a string ",Object(a.b)("inlineCode",{parentName:"p"},"$match")," option:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  // This matches `/settings`.\n  userSettings: {\n    $match: 'settings',\n  },\n});\n")),Object(a.b)("p",null,"To make the segment a segment parameter, we may add ",Object(a.b)("inlineCode",{parentName:"p"},"$match")," option as regular expression:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  // This matches both `/settings` and `/user-settings`.\n  userSettings: {\n    $match: /(?:user-)?settings/,\n  },\n});\n")),Object(a.b)("p",null,"And now we can get the actual matched segment by ",Object(a.b)("inlineCode",{parentName:"p"},"route.userSettings.$params.userSettings"),"."),Object(a.b)("p",null,"Please note that the regular expression must match the whole string of a segment. Assuming the path is ",Object(a.b)("inlineCode",{parentName:"p"},"/settings-suffix"),", even though ",Object(a.b)("inlineCode",{parentName:"p"},"/(?:user-)?settings/.test('settings-suffix')")," is true, but it won't match the route because it matches only ",Object(a.b)("inlineCode",{parentName:"p"},"settings")," instead of the whole segment ",Object(a.b)("inlineCode",{parentName:"p"},"settings-suffix"),"."),Object(a.b)("h3",{id:"exact-match"},"Exact Match"),Object(a.b)("p",null,"For route with children, by default it ignores the exact match. This means that the route previously defined does not match paths like:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"/account\n/account/123\n")),Object(a.b)("p",null,"To allow exact match for those parent routes, we need to set ",Object(a.b)("inlineCode",{parentName:"p"},"$exact")," as ",Object(a.b)("inlineCode",{parentName:"p"},"true")," respectively."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  account: {\n    $exact: true,\n    $children: {\n      /* ... */\n    },\n  },\n});\n")),Object(a.b)("h3",{id:"exact-match-default"},"Exact Match Default"),Object(a.b)("p",null,"Sometimes we might want a default child route to act as matched if its parent is exactly matched. E.g., for settings pages ",Object(a.b)("inlineCode",{parentName:"p"},"/settings/user")," and ",Object(a.b)("inlineCode",{parentName:"p"},"/settings/organization"),", we might want an exact match of ",Object(a.b)("inlineCode",{parentName:"p"},"/settings")," to act as if ",Object(a.b)("inlineCode",{parentName:"p"},"/settings/user")," is matched. And we may specify a string value for ",Object(a.b)("inlineCode",{parentName:"p"},"$exact")," to achieve that:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  settings: {\n    $exact: 'user',\n    $children: {\n      user: true,\n      organization: true,\n    },\n  },\n});\n")),Object(a.b)("p",null,"Note this value is not specified according to the key but the path segment. So if the key of the child route is ",Object(a.b)("inlineCode",{parentName:"p"},"awesomeUser"),", the ",Object(a.b)("inlineCode",{parentName:"p"},"$exact")," value should be ",Object(a.b)("inlineCode",{parentName:"p"},"awesome-user")," with default configuration."),Object(a.b)("h2",{id:"query"},"Query"),Object(a.b)("p",null,"The ability of handling query string in Boring Router is limited for now. It has some handful usages, but all ",Object(a.b)("inlineCode",{parentName:"p"},"$query")," definition is handled as optional strings without validations. This problem is partially solved by route ",Object(a.b)("inlineCode",{parentName:"p"},"extensions"),"/",Object(a.b)("inlineCode",{parentName:"p"},"services")," though."),Object(a.b)("p",null,"To get access to a specific query string, just add ",Object(a.b)("inlineCode",{parentName:"p"},"$query")," options and set a ",Object(a.b)("inlineCode",{parentName:"p"},"true")," value of the desired key:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  account: {\n    $query: {\n      group: true,\n      id: true,\n    },\n    $children: {\n      profile: true,\n    },\n  },\n});\n")),Object(a.b)("p",null,"Just like segment parameter, we can get a query string from ",Object(a.b)("inlineCode",{parentName:"p"},"$params"),". In this case, from both the route declaring the query string and its child route:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"route.account.$params.group;\nroute.account.$params.id;\nroute.account.profile.$params.group;\nroute.account.profile.$params.id;\n")),Object(a.b)("h3",{id:"query-string-preservation"},"Query String Preservation"),Object(a.b)("p",null,"By default, route builder (when you click a ",Object(a.b)("inlineCode",{parentName:"p"},"<Link>")," or trigger ",Object(a.b)("inlineCode",{parentName:"p"},"RouteMatch#$ref()"),' directly or indirectly) keeps query strings declared at the next matching route when creating a new "ref" for navigation. Think of the example below:'),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  account: {\n    $query: {\n      source: true,\n    },\n  },\n  about: {\n    $query: {\n      source: true,\n    },\n  },\n});\n")),Object(a.b)("p",null,"If the current route matches ",Object(a.b)("inlineCode",{parentName:"p"},"/account?source=123"),", the result of ",Object(a.b)("inlineCode",{parentName:"p"},"route.about.$ref()")," would be ",Object(a.b)("inlineCode",{parentName:"p"},"/about?source=123"),"."),Object(a.b)("p",null,"We can provide specific query IDs for different queries to achieve more accurate query string preservation:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  account: {\n    $query: {\n      source: 'account-source',\n    },\n  },\n  about: {\n    $query: {\n      source: 'about-source',\n    },\n  },\n});\n")),Object(a.b)("p",null,"A query ID could be either a string or a symbol. If ",Object(a.b)("inlineCode",{parentName:"p"},"true")," is provided, it will always preserve query string with the same key or be preserved by other query string with the same key."),Object(a.b)("h2",{id:"metadata"},"Metadata"),Object(a.b)("p",null,"You may add metadata to a specific route and its child route will automatically inherit the metadata."),Object(a.b)("p",null,"For example:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  user: {\n    $metadata: {\n      title: 'User',\n    },\n    $exact: true,\n    $children: {\n      settings: {\n        $metadata: {\n          subTitle: 'Settings',\n        },\n      },\n    },\n  },\n  workbench: {\n    $metadata: {\n      title: 'Workbench',\n    },\n  },\n});\n\nroute.user.$metadata; // {title: 'User'}\nroute.user.settings.$metadata; // {title: 'User', subTitle: 'Settings'}\n")),Object(a.b)("p",null,"Then we can use the metadata to update page title once the route changes:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"route.$afterEnterOrUpdate(\n  () => {\n    let {title, subTitle} = route.$rest.$metadata as {\n      title: string;\n      subTitle?: string;\n    };\n\n    document.title = `${subTitle ? `${subTitle} | ` : ''}${title}`;\n  },\n  {traceDescendants: true},\n);\n")),Object(a.b)("h2",{id:"extension"},"Extension"),Object(a.b)("p",null,"Boring Router provides a way to add addition property to a specific route through ",Object(a.b)("inlineCode",{parentName:"p"},"$extension")," route option:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  user: {\n    $query: {\n      id: true,\n    },\n    $extension: {\n      get user() {\n        return new User(route.user.$params.id);\n      },\n    },\n  },\n});\n")),Object(a.b)("p",null,"One of our common use case is just to provide type information with ",Object(a.b)("inlineCode",{parentName:"p"},"$extension")," and later have a route service to manage the actual value, with which more options are provided."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  user: {\n    $query: {\n      id: true,\n    },\n    $extension: {\n      user: undefined! as User,\n    },\n  },\n});\n\nroute.user.$service(match => new UserRouteService(match));\n\ntype UserRoute = typeof route.user;\n\nclass UserRouteService implements IRouteService<UserRoute> {\n  @observable\n  user!: User;\n\n  constructor(private match: UserRoute) {}\n\n  async willEnter(next: UserRoute['$next']): Promise<void> {\n    this.user = await getUser(next.$params.id);\n  }\n\n  afterLeave(): void {\n    this.user = undefined!;\n  }\n}\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Checkout ",Object(a.b)("a",o({parentName:"p"},{href:"./service"}),"Service")," for more information.")))}void 0!==u&&u&&u===Object(u)&&Object.isExtensible(u)&&!u.hasOwnProperty("__filemeta")&&Object.defineProperty(u,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"doc/references/route-schema.mdx"}}),u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---doc-references-route-schema-mdx-54d3cfa71319b07dd3ca.js.map