{"version":3,"sources":["webpack:///../doc/references/service.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"kfAMO,IAAMA,EAAe,Q,4MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,WADR,WAGA,8BAAa,0BAAYC,WAAW,KAAvB,cAAb,kIACA,2JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wPAWL,iBAAQ,CACN,GAAM,mBADR,mBAGA,qFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,4sBAgCL,8BACE,iBAAGA,WAAW,cAAd,2DAAuF,mBAAGA,WAAW,KAAQ,CACzG,KAAQ,sBAD2E,mBAAvF,iC,0MAQNJ,EAAWK,gBAAiB","file":"component---doc-references-service-mdx-77d7a9ec0c66745a8d22.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/root/workspace/boring-router/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"service\"\n    }}>{`Service`}</h1>\n    <p>{`Every `}<inlineCode parentName=\"p\">{`RouteMatch`}</inlineCode>{` can be backed by a route service in Boring Router, providing additional flexibility with states comparing to lifecycle hooks.`}</p>\n    <p>{`A route service gets only \"activated\" when the route matches. And we can provide both pre-instantiated service or service factory:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route.account.$service(new AccountRouteService());\n\nroute.settings.$service(match => new SettingsRouteService(match));\n\nroute.workbench.$service(async match => {\n  // asynchronous code...\n  return new WorkbenchRouteService(match);\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"lifecycle-hooks\"\n    }}>{`Lifecycle Hooks`}</h2>\n    <p>{`Lifecycle hooks is supported by service as optional methods:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`type AccountRoute = typeof route.account;\n\nclass AccountRouteService implements IRouteService<AccountRoute> {\n  constructor(private match: AccountRoute) {}\n\n  async beforeEnter(next: AccountRoute['$next']): Promise<void> {}\n\n  async willEnter(next: AccountRoute['$next']): Promise<void> {}\n\n  async afterEnter(): void {}\n\n  async beforeUpdate(next: AccountRoute['$next']): Promise<void> {\n    this.beforeEnter(next);\n  }\n\n  async willUpdate(next: AccountRoute['$next']): Promise<void> {\n    this.willEnter(next);\n  }\n\n  async afterUpdate(): void {\n    this.afterEnter();\n  }\n\n  async beforeLeave(): Promise<void> {}\n\n  async willLeave(): Promise<void> {}\n\n  afterLeave(): void {}\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`For full signatures of lifecycle hook methods, checkout `}<a parentName=\"p\" {...{\n          \"href\": \"./lifecycle-hooks\"\n        }}>{`Lifecycle Hooks`}</a>{` and type information.`}</p>\n    </blockquote>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}