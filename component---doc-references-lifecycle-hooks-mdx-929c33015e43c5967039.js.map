{"version":3,"sources":["webpack:///../doc/references/lifecycle-hooks.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"kfAMO,IAAMA,EAAe,Q,oNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,mBADR,mBAGA,iBAAQ,CACN,GAAM,YADR,YAGA,+KAA8J,mBAAGC,WAAW,KAAQ,CAChL,KAAQ,kDADkJ,gBAA9J,kEAGA,6QAA4P,0BAAYA,WAAW,KAAvB,eAA5P,mEAAuX,0BAAYA,WAAW,KAAvB,UAAvX,0MAAonB,0BAAYA,WAAW,KAAvB,kBAApnB,qFAAowB,mBAAGA,WAAW,KAAQ,CACtxB,KAAQ,6CADwvB,WAApwB,aAGA,kGAAiF,0BAAYA,WAAW,KAAvB,qBAAjF,MAAqJ,0BAAYA,WAAW,KAAvB,sBAArJ,KACA,iBAAQ,CACN,GAAM,eADR,eAGA,iBAAQ,CACN,GAAM,gBADR,gBAGA,wCAAuB,0BAAYA,WAAW,KAAvB,eAAvB,IAAmF,0BAAYA,WAAW,KAAvB,gBAAnF,IAAgJ,0BAAYA,WAAW,KAAvB,eAAhJ,kRACA,6CAA4B,0BAAYA,WAAW,KAAvB,SAA5B,qJACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,8JAOL,iBAAQ,CACN,GAAM,cADR,cAGA,sCAAqB,0BAAYA,WAAW,KAAvB,aAArB,IAA+E,0BAAYA,WAAW,KAAvB,cAA/E,IAA0I,0BAAYA,WAAW,KAAvB,aAA1I,qWACA,iBAAQ,CACN,GAAM,eADR,eAGA,uCAAsB,0BAAYA,WAAW,KAAvB,cAAtB,IAAiF,0BAAYA,WAAW,KAAvB,eAAjF,IAA6I,0BAAYA,WAAW,KAAvB,cAA7I,mT,kNAKJJ,EAAWK,gBAAiB","file":"component---doc-references-lifecycle-hooks-mdx-929c33015e43c5967039.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/root/workspace/boring-router/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"lifecycle-hooks\"\n    }}>{`Lifecycle Hooks`}</h1>\n    <h2 {...{\n      \"id\": \"overview\"\n    }}>{`Overview`}</h2>\n    <p>{`Boring Router is a state-first router of which the core has nothing to do with React components. This makes Boring Router fundamentally different with `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/ReactTraining/react-router\"\n      }}>{`React Router`}</a>{` and removes the first barrier providing full lifecycle hooks.`}</p>\n    <p>{`The second barrier of full lifecycle hooks support is browser history stack. As navigation can happen without accessing the router managed by us (e.g., user clicking \"back\", \"forward\" and even \"goto\"), it is unavoidable for lifecycle hooks like `}<inlineCode parentName=\"p\">{`beforeEnter`}</inlineCode>{` to be called after the navigation actually happens. To support `}<inlineCode parentName=\"p\">{`before`}</inlineCode>{` hooks, we need to acquire the ability to restore history stack to a previous state. Otherwise, we will have broken browser navigation behavior. To solve this problem, we choose to implement our own `}<inlineCode parentName=\"p\">{`BrowserHistory`}</inlineCode>{` with the ability to track and restore history stack instead of using the popular `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/ReactTraining/history\"\n      }}>{`history`}</a>{` package.`}</p>\n    <p>{`Those make it possible for Boring Router to support full lifecycle hooks: `}<inlineCode parentName=\"p\">{`before/will/after`}</inlineCode>{` x `}<inlineCode parentName=\"p\">{`enter/update/leave`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"hook-phases\"\n    }}>{`Hook Phases`}</h2>\n    <h3 {...{\n      \"id\": \"before-hooks\"\n    }}>{`Before Hooks`}</h3>\n    <p>{`\"Before hooks\" (`}<inlineCode parentName=\"p\">{`beforeEnter`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`beforeUpdate`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`beforeLeave`}</inlineCode>{`) are called before applying a navigation. All of the \"before hooks\" support asynchronous callbacks and allow cancellation or interruption in between. This means if another navigation is queued before \"before\" phase completes, the current navigation will be interrupted.`}</p>\n    <p>{`So besides returning `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{` in a \"before hook\" to cancel a navigation, it is designed to allow additional navigation within a \"before hook\" to interrupt current navigation:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`route.task.numericId.$beforeEnter(async next => {\n  let id = await getTaskIdByNumericId(next.$params.numericId);\n  route.task.id.$replace({id});\n});\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"will-hooks\"\n    }}>{`Will Hooks`}</h3>\n    <p>{`\"Will hooks\" (`}<inlineCode parentName=\"p\">{`willEnter`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`willUpdate`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`willLeave`}</inlineCode>{`) are called once all the \"before hooks\" are called and the navigation has not been cancelled or interrupted. \"Will hooks\" can also be asynchronous. But unlike \"before hooks\", it cannot cancel or interrupt a happening navigation. If another navigation is queued before \"will\" phase completes, it will be processed after the current navigation completes.`}</p>\n    <h3 {...{\n      \"id\": \"after-hooks\"\n    }}>{`After Hooks`}</h3>\n    <p>{`\"After hooks\" (`}<inlineCode parentName=\"p\">{`afterEnter`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`afterUpdate`}</inlineCode>{`/`}<inlineCode parentName=\"p\">{`afterLeave`}</inlineCode>{`) are called just before navigation completes. The wording \"after\" is still considered accurate, because at this phase the route states have already been updated. \"After hooks\" are synchronous hooks, you can do anything you want in those hooks as it's no longer within the scope of Boring Router.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}