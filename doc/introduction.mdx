---
name: Introduction
route: /
---

# Introduction

Boring Router is a state-first router with light-weight route components. It manages observable (MobX) route states like `route.$matched` and `route.$params`, so the route components as well as your code can react to those states. Boring Router is written in TypeScript and it puts type safety in mind designing the API.

## Route Notation

Boring Router uses schema-based, type-safe route notation. You don't need, and it is not recommended to write routes as strings with Boring Router.

```ts
const route = router.$route({
  workbench: {
    $children: {
      taskId: {
        $match: /\d+/,
      },
    },
  },
});
```

```tsx
<Route match={route.workbench.taskId} component={WorkbenchTaskView} />
```

```tsx
<Link to={route.workbench.taskId} params={{taskId: '123'}}>
  Go to Task
</Link>
```

Route schema can be shared with Node.js backend and this makes route notations type-safe everywhere.

## Parallel Routes

Views like sidebar, overlay can be easily routed with Boring Router parallel routes.

```ts
const route = router.$route({
  /* primary route schema */
});

const sidebarRoute = router.$route('sidebar', {
  /* sidebar route shema */
});
```

URL for parallel routes looks like `/workbench?_sidebar=/notifications`. Additional parallel routes work like primary route except that it does not have dedicated query strings.

## Life-cycle Hooks

Boring Router supports `before/will/after` x `enter/update/leave` hooks.

```ts
route.workbench.$beforeEnter(async next => {
  let {referrer} = next.$params;

  if (await testReferrer(referrer)) {
    return;
  }

  route.default.$replace();
});
```

To support full life-cycle hooks while keeping history navigation behavior right, Boring Router implements its own `BrowserHistory` with the ability to restore browser history stack according to a given snapshot.
