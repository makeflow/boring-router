(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{nCky:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return c})),n.d(t,"default",(function(){return u}));n("5hJT"),n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("PJhk"),n("mXGw");var r=n("/FXl"),a=n("TjRS");n("aD51");function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"doc/references/route-schema.md"}});var i={_frontmatter:c},s=a.a;function u(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,["components"]);return Object(r.b)(s,o({},i,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"route-schema"},"Route Schema"),Object(r.b)("h2",{id:"overview"},"Overview"),Object(r.b)("p",null,"Boring Router defines routes by tree-structure route schemas:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    account: {\n      $children: {\n        accountId: {\n          $match: /\\d+/,\n          $children: {\n            profile: {\n              $query: {\n                'show-comment': true,\n              },\n            },\n            contact: true,\n          },\n        },\n      },\n    },\n  },\n});\n")),Object(r.b)("p",null,"The route defined above matches paths like below:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{}),"/account/123/profile\n/account/123/profile?show-comment=on\n/account/456/contact\n")),Object(r.b)("p",null,"And it creates route objects (",Object(r.b)("inlineCode",{parentName:"p"},"RouteMatch"),") that can be accessed using:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"route;\nroute.account;\nroute.account.accountId;\nroute.account.accountId.profile;\nroute.account.accountId.contact;\n")),Object(r.b)("p",null,"To get a parameter (including segment parameter and query string) from a route, we need to access ",Object(r.b)("inlineCode",{parentName:"p"},"$params")," of the target route object."),Object(r.b)("p",null,"In this case, to get ",Object(r.b)("inlineCode",{parentName:"p"},"accountId"),", we need to use ",Object(r.b)("inlineCode",{parentName:"p"},"route.account.accountId.$params.accountId"),". This might look a little bit weird at the beginning (maybe forever), but it's also reasonable: because ",Object(r.b)("inlineCode",{parentName:"p"},"accountId")," (the segment parameter) is one of the properties of route ",Object(r.b)("inlineCode",{parentName:"p"},"route.account.accountId"),", and its name by convention is the same as the route key."),Object(r.b)("p",null,"We can also get the parameter from a child route object, e.g.: ",Object(r.b)("inlineCode",{parentName:"p"},"route.account.accountId.profile.$params.accountId"),"."),Object(r.b)("h2",{id:"match"},"Match"),Object(r.b)("p",null,"By adding a child under ",Object(r.b)("inlineCode",{parentName:"p"},"$children"),", we create a ",Object(r.b)("inlineCode",{parentName:"p"},"RouteMatch")," for the correspondent segment:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    // Simply use `true` for default options.\n    workbench: true,\n    // Specify route options with an object.\n    settings: {\n      $match: /boring/,\n      $children: {\n        security: true,\n        notification: true,\n      },\n    },\n  },\n});\n")),Object(r.b)("h3",{id:"segment-match"},"Segment Match"),Object(r.b)("p",null,'By default, Boring Router matches a segment according to the "hyphenated" string of the route key.'),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    // This matches `/user-settings`.\n    userSettings: true,\n  },\n});\n")),Object(r.b)("p",null,"To match another fixed string, we may add a string ",Object(r.b)("inlineCode",{parentName:"p"},"$match")," option:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    // This matches `/settings`.\n    userSettings: {\n      $match: 'settings',\n    },\n  },\n});\n")),Object(r.b)("p",null,"To make the segment a segment parameter, we may add ",Object(r.b)("inlineCode",{parentName:"p"},"$match")," option as regular expression:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    // This matches both `/settings` and `/user-settings`.\n    userSettings: {\n      $match: /(?:user-)?settings/,\n    },\n  },\n});\n")),Object(r.b)("p",null,"And now we can get the actual matched segment by ",Object(r.b)("inlineCode",{parentName:"p"},"route.userSettings.$params.userSettings"),"."),Object(r.b)("p",null,"Please note that the regular expression must match the whole string of a segment. Assuming the path is ",Object(r.b)("inlineCode",{parentName:"p"},"/settings-suffix"),", even though ",Object(r.b)("inlineCode",{parentName:"p"},"/(?:user-)?settings/.test('settings-suffix')")," is true, but it won't match the route because the regular expression matches only ",Object(r.b)("inlineCode",{parentName:"p"},"settings")," instead of the whole segment ",Object(r.b)("inlineCode",{parentName:"p"},"settings-suffix"),"."),Object(r.b)("h3",{id:"exact-match"},"Exact Match"),Object(r.b)("p",null,"For route with children, by default it ignores the exact match. This means that the route defined in the ",Object(r.b)("a",o({parentName:"p"},{href:"#overview"}),"Overview")," section does not match paths like:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{}),"/account\n/account/123\n")),Object(r.b)("p",null,"To allow exact match for those parent routes, we need to set ",Object(r.b)("inlineCode",{parentName:"p"},"$exact")," as ",Object(r.b)("inlineCode",{parentName:"p"},"true")," respectively."),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    account: {\n      $exact: true,\n      $children: {\n        /* ... */\n      },\n    },\n  },\n});\n")),Object(r.b)("h3",{id:"exact-match-default"},"Exact Match Default"),Object(r.b)("p",null,"Sometimes we might want a default child route to act as matched if its parent is exactly matched. E.g., for settings pages ",Object(r.b)("inlineCode",{parentName:"p"},"/settings/user")," and ",Object(r.b)("inlineCode",{parentName:"p"},"/settings/organization"),", we might want an exact match of ",Object(r.b)("inlineCode",{parentName:"p"},"/settings")," to act as if ",Object(r.b)("inlineCode",{parentName:"p"},"/settings/user")," is matched. And we may specify a string value for ",Object(r.b)("inlineCode",{parentName:"p"},"$exact")," to achieve that:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    settings: {\n      $exact: 'user',\n      $children: {\n        user: true,\n        organization: true,\n      },\n    },\n  },\n});\n")),Object(r.b)("p",null,"Note this value is not specified according to the key but the path segment. So if the key of the child route is ",Object(r.b)("inlineCode",{parentName:"p"},"awesomeUser"),", the ",Object(r.b)("inlineCode",{parentName:"p"},"$exact")," value should be ",Object(r.b)("inlineCode",{parentName:"p"},"awesome-user")," with default configuration."),Object(r.b)("h2",{id:"query"},"Query"),Object(r.b)("p",null,"The ability of handling query string in Boring Router is limited for now. It has some handy usages, but all ",Object(r.b)("inlineCode",{parentName:"p"},"$query")," definition is handled as optional strings without validations."),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"This problem can be partially solved by ",Object(r.b)("a",o({parentName:"p"},{href:"/boring-router/references/route-schema#extension"}),"Extension")," & ",Object(r.b)("a",o({parentName:"p"},{href:"/boring-router/references/service#managed-extension"}),"Service"),".")),Object(r.b)("p",null,"To get access to a specific query string, just add ",Object(r.b)("inlineCode",{parentName:"p"},"$query")," options and set a ",Object(r.b)("inlineCode",{parentName:"p"},"true")," value of the desired key:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        group: true,\n        id: true,\n      },\n      $children: {\n        profile: true,\n      },\n    },\n  },\n});\n")),Object(r.b)("p",null,"Just like segment parameter, we can get a query string from ",Object(r.b)("inlineCode",{parentName:"p"},"$params"),". In this case, from both the route declaring the query string and its child route:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"route.account.$params.group;\nroute.account.$params.id;\nroute.account.profile.$params.group;\nroute.account.profile.$params.id;\n")),Object(r.b)("h3",{id:"query-string-preservation"},"Query String Preservation"),Object(r.b)("p",null,"By default, route builder (when you click a ",Object(r.b)("inlineCode",{parentName:"p"},"<Link>")," or trigger ",Object(r.b)("inlineCode",{parentName:"p"},"RouteMatch#$ref()"),' directly or indirectly) keeps query strings declared at the next matching route when creating a new "ref" for navigation. Think of the example below:'),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        source: true,\n      },\n    },\n    about: {\n      $query: {\n        source: true,\n      },\n    },\n  },\n});\n")),Object(r.b)("p",null,"If the current route matches ",Object(r.b)("inlineCode",{parentName:"p"},"/account?source=123"),", the result of ",Object(r.b)("inlineCode",{parentName:"p"},"route.about.$ref()")," would be ",Object(r.b)("inlineCode",{parentName:"p"},"/about?source=123"),"."),Object(r.b)("p",null,"We can provide specific query IDs for different queries to achieve more accurate query string preservation:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    account: {\n      $query: {\n        source: 'account-source',\n      },\n    },\n    about: {\n      $query: {\n        source: 'about-source',\n      },\n    },\n  },\n});\n")),Object(r.b)("p",null,"A query ID could be either a string or a symbol. If ",Object(r.b)("inlineCode",{parentName:"p"},"true")," is provided, it will always preserve query string with the same key or be preserved by other query string with the same key."),Object(r.b)("h2",{id:"metadata"},"Metadata"),Object(r.b)("p",null,"You may add metadata to a specific route and its child route will automatically inherit the metadata."),Object(r.b)("p",null,"For example:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    user: {\n      $metadata: {\n        title: 'User',\n      },\n      $exact: true,\n      $children: {\n        settings: {\n          $metadata: {\n            subTitle: 'Settings',\n          },\n        },\n      },\n    },\n    workbench: {\n      $metadata: {\n        title: 'Workbench',\n      },\n    },\n  },\n});\n\nroute.user.$metadata; // {title: 'User'}\nroute.user.settings.$metadata; // {title: 'User', subTitle: 'Settings'}\n")),Object(r.b)("p",null,"Then we can use the metadata to update page title once the route changes:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"route.$afterEnterOrUpdate(\n  () => {\n    let {title, subTitle} = route.$rest.$metadata as {\n      title: string;\n      subTitle?: string;\n    };\n\n    document.title = `${subTitle ? `${subTitle} | ` : ''}${title}`;\n  },\n  {traceDescendants: true},\n);\n")),Object(r.b)("h2",{id:"extension"},"Extension"),Object(r.b)("p",null,"Boring Router provides a way to add addition property to a specific route through ",Object(r.b)("inlineCode",{parentName:"p"},"$extension")," route option:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    user: {\n      $query: {\n        id: true,\n      },\n      $extension: {\n        get user() {\n          return new User(route.user.$params.id);\n        },\n      },\n    },\n  },\n});\n")),Object(r.b)("p",null,"One of our common use case is just to provide type information with ",Object(r.b)("inlineCode",{parentName:"p"},"$extension")," and later have a route service to manage the actual value, with which more options are provided."),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const route = router.$route({\n  $children: {\n    user: {\n      $query: {\n        id: true,\n      },\n      $extension: {\n        user: undefined! as User,\n      },\n    },\n  },\n});\n\nroute.user.$service(match => new UserRouteService(match));\n\ntype UserRoute = typeof route.user;\n\nclass UserRouteService implements IRouteService<UserRoute> {\n  @observable\n  user!: User;\n\n  constructor(private match: UserRoute) {}\n\n  async willEnter(next: UserRoute['$next']): Promise<void> {\n    this.user = await getUser(next.$params.id);\n  }\n\n  afterLeave(): void {\n    this.user = undefined!;\n  }\n}\n")),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"Checkout ",Object(r.b)("a",o({parentName:"p"},{href:"/boring-router/references/service"}),"Service")," for more information.")))}void 0!==u&&u&&u===Object(u)&&Object.isExtensible(u)&&!u.hasOwnProperty("__filemeta")&&Object.defineProperty(u,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"doc/references/route-schema.md"}}),u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---doc-references-route-schema-md-8d4b7fef3621fe1f5df1.js.map